{
  "id": "tensor_robust_principal_component_analysis_with_a_new_tensor_nuclear_norm",
  "title": "Tensor Robust Principal Component Analysis with a New Tensor Nuclear Norm",
  "authors": [
    "CanyiLu",
    "JiashiFeng",
    "YudongChen",
    "Member, IEEEWeiLiu",
    "Fellow, IEEEZhouchenLin",
    "Fellow, IEEEShuichengYan",
    "Department of Electrical and Computer Engineering\n\t\t\t\t\t\t\t\tCarnegie Mellon University\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t15213.\n\t\t\t\t\t\t\t\t\tPittsburgh\n\t\t\t\t\t\t\t\t\tPA",
    "Department of Electrical and Computer Engineering\n\t\t\t\t\t\t\t\tNational University of Singapore\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t119077\n\t\t\t\t\t\t\t\t\tSingapore",
    "School of Operations Research and Information Engineering\n\t\t\t\t\t\t\t\tCornell University\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t14850.\n\t\t\t\t\t\t\t\t\tIthaca\n\t\t\t\t\t\t\t\t\tNY",
    "School of Electronics Engineering and Computer Science\n\t\t\t\t\t\t\t\tLaboratory of Machine Perception (MOE)\n\t\t\t\t\t\t\t\tTencent AI Lab\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tShenzhen\n\t\t\t\t\t\t\t\t\tChina",
    "Peking University\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t100871\n\t\t\t\t\t\t\t\t\tBeijing\n\t\t\t\t\t\t\t\t\tChina"
  ],
  "content": "P RINCIPAL Component Analysis (PCA) is a fundamen- tal approach for data analysis. It exploits low-dimensional structure in high-dimensional data, which commonly exists in different types of data, e.g., image, text, video and bioinformatics. It is computationally efficient and powerful for data instances which are mildly corrupted by small noises. However, a major issue of PCA is that it is brittle to be grossly corrupted or outlying observations, which are ubiquitous in real-world data. To date, a number of robust versions of PCA have been proposed, but many of them suffer from a high computational cost. The Robust PCA [3] is the first polynomial-time algorithm with strong recovery guarantees. Suppose that we are given an observed matrix X X 2 R n 1 Ân 2 , which can be decomposed as X X ¼ L L 0 þ E E 0 , where L L 0 is low-rank and E E 0 is sparse. It is shown in [3] that if the singular vectors of L L 0 satisfy some incoherent conditions, e.g., L L 0 is lowrank and E E 0 is sufficiently sparse, then L L 0 and E E 0 can be exactly recovered with high probability by solving the following convex problem where kL Lk Ã denotes the nuclear norm (sum of the singular values of L L), and kE Ek 1 denotes the ' 1 -norm (sum of the absolute values of all the entries in E E). Theoretically, RPCA is guaranteed to work even if the rank of L L 0 grows almost linearly in the dimension of the matrix, and the errors in E E 0 are up to a constant fraction of all entries. The parameter is suggested to be set as 1= ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi maxðn 1 ; n 2 Þ p which works well in practice. Algorithmically, program (1) can be solved by efficient algorithms, at a cost not too much higher than PCA. RPCA and its extensions have been successfully applied to background modeling [3], subspace clustering [16], video compressive sensing [28], etc. One major shortcoming of RPCA is that it can only handle 2-way (matrix) data. However, real data is usually multi-dimensional in nature-the information is stored in multi-way arrays known as tensors [15]. For example, a color image is a 3-way object with column, row and color modes; a greyscale video is indexed by two spatial variables and one temporal variable. To use RPCA, one has to first restructure the multi-way data into a matrix. Such a preprocessing usually leads to an information loss and would cause a performance degradation. To alleviate this issue, it is natural to consider extending RPCA to manipulate the tensor data by taking advantage of its multi-dimensional structure. In this work, we are interested in the Tensor Robust Principal Component (TRPCA) model which aims to exactly recover a low-rank tensor corrupted by sparse errors. See Fig. 1 for an intuitive illustration. More specifically, suppose that we are given a data tensor X X , and know that it can be decomposed as where L L 0 is low-rank and E E 0 is sparse, and both components are of arbitrary magnitudes. Note that we do not know the locations of the nonzero elements of E E 0 , not even how many there are. Now we consider a similar problem to RPCA. Can we recover the low-rank and sparse components exactly and efficiently from X X ? This is the problem of tensor RPCA studied in this work. The tensor extension of RPCA is not easy since the numerical algebra of tensors is fraught with hardness results [5], [8], [11]. A main issue is that the tensor rank is not well defined with a tight convex relaxation. Several tensor rank definitions and their convex relaxations have been proposed but each has its limitation. For example, the CP rank [15], defined as the smallest number of rank one tensor decomposition, is generally NP-hard to compute. Also its convex relaxation is intractable. This makes the low CP rank tensor recovery challenging. The tractable Tucker rank [15] and its convex relaxation are more widely used. For a k-way tensor X X , the Tucker rank is a vector defined as rank tc ðX XÞ :¼ rankðX X f1g Þ; rankðX X f2g Þ; . . . ; rankðX X fkg Þ À Á , where X X fig is the mode-i matricization of X X [15]. Motivated by the fact that the nuclear norm is the convex envelope of the matrix rank within the unit ball of the spectral norm, the Sum of Nuclear Norms (SNN) [17], defined as where i > 0, and P P V V ðX XÞ denotes the projection of X X on the observed set V V. The effectiveness of this approach for image processing has been well studied in [17], [27]. However, SNN is not the convex envelope of P i rankðX X fig Þ [25]. Actually, the above model can be substantially suboptimal [23]: reliably recovering a k-way tensor of length n and Tucker rank ðr; r; . . . ; rÞ from Gaussian measurements requires Oðrn kÀ1 Þ observations. In contrast, a certain (intractable) nonconvex formulation needs only OðrK þ nrKÞ observations. A better (but still suboptimal) convexification based on a more balanced matricization is proposed in [23]. The work [12] presents the recovery guarantee for the SNN based tensor RPCA model A robust tensor CP decomposition problem is studied in [6]. Though the recovery is guaranteed, the algorithm is nonconvex. The limitations of existing works motivate us to consider an interesting problem: is it possible to define a new tensor nuclear norm such that it is a tight convex surrogate of certain tensor rank, and thus its resulting tensor RPCA enjoys a similar tight recovery guarantee to that of the matrix RPCA? This work will provide a positive answer to this question. Our solution is inspired by the recently proposed tensor-tensor product (t-product) [14] which is a generalization of the matrix-matrix product. It enjoys several similar properties to the matrix-matrix product. For example, based on t-product, any tensors have the tensor Singular Value Decomposition (t-SVD) and this motivates a new tensor rank, i.e., tensor tubal rank [13]. To recover a tensor of low tubal rank, we propose a new tensor nuclear norm which is rigorously induced by the t-product. First, the tensor spectral norm can be induced by the operator norm when treating the t-product as an operator. Then the tensor nuclear norm is defined as the dual norm of the tensor spectral norm. We further propose the tensor average rank (which is closely related to the tensor tubal rank), and prove that its convex envelope is the tensor nuclear norm within the unit ball of the tensor spectral norm. It is interesting that this framework, including the new tensor concepts and their relationships, is consistent with the one for the matrix cases. Equipped with these new tools, we then study the TRPCA problem which aims to recover the low tubal rank component L L 0 and sparse component E E 0 from noisy observations X X ¼ L L 0 þ E E 0 2 R n 1 Ân 2 Ân 3 (this work focuses on the 3-way tensor) by convex optimization where kL Lk Ã is our new tensor nuclear norm (see the definition in Section 3). We prove that under certain incoherence conditions, the solution to (5) perfectly recovers the low-rank and the sparse components, provided of course that the tubal rank of L L 0 is not too large, and that E E 0 is reasonably sparse. A remarkable fact, like in RPCA, is that (5) has no tunning parameter either. Our analysis shows that ¼ 1= ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi maxðn 1 ; n 2 Þn 3 p guarantees the exact recovery when L L 0 and E E 0 satisfy certain assumptions. As a special case, if X X reduces to a matrix (n 3 ¼ 1 in this case), all the new tensor concepts reduce to the matrix cases. Our TRPCA model (5) reduces to RPCA in (1), and also our recovery guarantee in Theorem 4.1 reduces to Theorem 1.1 in [3]. Another advantage of ( 5) is that it can be solved by polynomial-time algorithms. The contributions of this work are summarized as follows: 1. Motivated by the t-product [14] which is a natural generalization of the matrix-matrix product, we rigorously deduce a new tensor nuclear norm and some other related tensor concepts, and they own the same relationship as the matrix cases. This is the foundation for the extensions of the models, optimization method and theoretical analyzing techniques from matrix cases to tensor cases. 2. Equipped with the tensor nuclear norm, we theoretically show that under certain incoherence conditions, the solution to the convex TRPCA model ( 5) perfectly recovers the underlying low-rank component L L 0 and sparse component E E 0 . RPCA [3] and its recovery guarantee fall into our special cases. 3. We give a new rigorous proof of t-SVD factorization and a more efficient way than [18] for solving TRPCA. We further perform several simulations to corroborate our theoretical results. Numerical experiments on images and videos also show the superiority of TRPCA over RPCA and SNN. The rest of this paper is structured as follows. Section 2 gives some notations and preliminaries. Section 3 presents the way for defining the tensor nuclear norm induced by the t-product. Section 4 provides the recovery guarantee of TRPCA and the optimization details. Section 5 presents numerical experiments conducted on synthetic and real data. We conclude this work in Section 6. In this paper, we denote tensors by boldface Euler script letters, e.g., A A. Matrices are denoted by boldface capital letters, e.g., A A; vectors are denoted by boldface lowercase letters, e.g., a a, and scalars are denoted by lowercase letters, e.g., a. We denote I I n as the n Â n identity matrix. The fields of real numbers and complex numbers are denoted as R and C, respectively. For a 3-way tensor A A 2 C n 1 Ân 2 Ân 3 , we denote its ði; j; kÞth entry as A A ijk or a ijk and use the Matlab notation A Aði; :; :Þ, A Að:; i; :Þ and A Að:; :; iÞ to denote respectively the ith horizontal, lateral and frontal slice (see definitions in [15]). More often, the frontal slice A Að:; :; iÞ is denoted compactly as A A ðiÞ . The tube is denoted as A Aði; j; :Þ. The inner product between A A and B B in C n 1 Ân 2 is defined as A A; B B h i¼ TrðA A Ã B BÞ, where A A Ã denotes the conjugate transpose of A A and TrðÁÞ denotes the matrix trace. The inner product between A A and B B in C n 1 Ân 2 Ân 3 is defined as hA A; B Bi ¼ P n 3 i¼1 hA A ðiÞ ; B B ðiÞ i. For any A A 2 C n 1 Ân 2 Ân 3 , the complex conjugate of A A is denoted as conjðA AÞ which takes the complex conjugate of each entry of A A. We denote t b c as the nearest integer less than or equal to t and dte as the one greater than or equal to t. Some norms of vector, matrix and tensor are used. We denote the ' 1 -norm as kA Ak 1 ¼ P ijk ja ijk j, the infinity norm as kA Ak 1 ¼ max ijk ja ijk j and the Frobenius norm as kA Ak F ¼ ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi P ijk ja ijk j 2 q , respectively. The above norms reduce to the vector or matrix norms if A A is a vector or a matrix. For . The spectral norm of a matrix A A is denoted as kA Ak ¼ max i s i ðA AÞ, where s i ðA AÞ's are the singular values of A A. The matrix nuclear norm is kA Ak Ã ¼ P i s i ðA AÞ. The Discrete Fourier Transformation (DFT) plays a core role in tensor-tensor product introduced later. We give some related background knowledge and notations here. The DFT on v v 2 R n , denoted as v v, is given by where F F n is the DFT matrix defined as Thus F F À1 n ¼ F F Ã n =n. The above property will be frequently used in this paper. Computing v v by using (6) costs Oðn 2 Þ. A more widely used method is the Fast Fourier Transform (FFT) which costs Oðn log nÞ. By using the Matlab command fft, we have v v ¼ fftðv vÞ. Denote the circulant matrix of v v as It is known that it can be diagonalized by the DFT matrix, i.e., where Diagð v vÞ denotes a diagonal matrix with its ith diagonal entry as v i . The above equation implies that the columns of F F n are the eigenvectors of ðcircðv vÞÞ > and v i 's are the corresponding eigenvalues. Lemma 2.1 ( [24]). Given any real vector v v 2 R n , the associated Conversely, for any given complex v v 2 C n satisfying (9), there exists a real block circulant matrix circðv vÞ such that (8) holds. As will be seen later, the above properties are useful for efficient computation and important for proofs. Now we consider the DFT on tensors. For A A 2 R n 1 Ân 2 Ân 3 , we denote A A 2 C n 1 Ân 2 Ân 3 as the result of DFT on A A along the 3-rd dimension, i.e., performing the DFT on all the tubes of A A. By using the Matlab command fft, we have A A ¼ fftðA A; ½ ; 3Þ: In a similar fashion, we can compute A A from A A using the inverse FFT, i.e., A A; ½ ; 3Þ: In particular, we denote where bdiag is an operator which maps the tensor A A to the block diagonal matrix A A. Also, we define the block circulant matrix bcircðA AÞ 2 R n 1 n 3 Ân 2 n 3 of A A as bcircðA AÞ ¼ Just like the circulant matrix which can be diagonalized by DFT, the block circulant matrix can be block diagonalized, i.e., where denotes the Kronecker product and ðF Conversely, for any given A A 2 C n 1 Ân 2 Ân 3 satisfying ( 11), there exists a real tensor A A 2 R n 1 Ân 2 Ân 3 such that (10) holds. Also, by using ( 7), we have the following properties which will be used frequently: where the unfold operator maps A A to a matrix of size n 1 n 3 Â n 2 and fold is its inverse operator. The t-product can be understood from two perspectives. First, in the original domain, a 3-way tensor of size n 1 Â n 2 Â n 3 can be regarded as an n 1 Â n 2 matrix with each entry being a tube that lies in the third dimension. Thus, the t-product is analogous to the matrix multiplication except that the circular convolution replaces the multiplication operation between the elements. Note that the t-product reduces to the standard matrix multiplication when n 3 ¼ 1. This is a key observation which makes our tensor RPCA model shown later involve the matrix RPCA as a special case. Second, the t-product is equivalent to the matrix multiplication in the Fourier domain; that is, where ( 15) uses (10). Left multiplying both sides with ðF This property suggests an efficient way based on FFT to compute t-product instead of using (14). See Algorithm 1. The t-product enjoys many similar properties to the matrix-matrix product. For example, the t-product is associative, i.e., A A Ã ðB B Ã C CÞ ¼ ðA A Ã B BÞ Ã C C. We also need some other concepts on tensors extended from the matrix cases. obtained by conjugate transposing each of the frontal slices and then reversing the order of transposed frontal slices 2 through n 3 . The tensor conjugate transpose extends the tensor transpose [14] for complex tensors. As an example, let Definition 2.3 ((Identity tensor) [14]). The identity tensor I I 2 R nÂnÂn 3 is the tensor with its first frontal slice being the n Â n identity matrix, and other frontal slices being all zeros. given the appropriate dimensions. The tensor I I ¼ fftðI I; ½ ; 3Þ is a tensor with each frontal slice being the identity matrix. Then it can be factorized as where Proof. The proof is by construction. Recall that (10) holds and A A ðiÞ 's satisfy the property (11). Then we construct the SVD of each A A ðiÞ in the following way. For i ¼ 1; . . . ; Here the singular values in S S ðiÞ are real. For i By the construction of U U, S S and V V , and Lemma 2.1, we have that ðF are real block circulant matrices. Then we can obtain an expression for bcircðA AÞ by applying the appropriate matrix ðF F À1 n 3 I I n 1 Þ to the left and the appropriate matrix ðF F n 3 I I n 2 Þ to the right of each of the matrices in (17), and folding up the result. This gives a decomposition of the form U U Ã S S Ã V V Ã , where U U, S S and V V are real. t u end for 3. Compute U U ¼ ifftð U U; ½ ; 3Þ, S S ¼ ifftð S S; ½ ; 3Þ, and Theorem 2.2 shows that any 3 way tensor can be factorized into 3 components, including 2 orthogonal tensors and an f-diagonal tensor. See Fig. 2 for an intuitive illustration of the t-SVD factorization. T-SVD reduces to the matrix SVD when n 3 ¼ 1. We would like to emphasize that the result of Theorem 2.2 was given first in [14] and later in some other related works [10], [21]. But their proof and the way for computing U U and V V are not rigorous. The issue is that their method cannot guarantee that U U and V V are real tensors. They construct each frontal slice U U ðiÞ (or V V ðiÞ ) of U U (or V V resp.) from the SVD of A A ðiÞ independently for all i ¼ 1; . . . ; n 3 . However, the matrix SVD is not unique. Thus, U U ðiÞ 's and V V ðiÞ 's may not satisfy property (11) even though A A ðiÞ 's do. In this case, the obtained U U (or V V) from the inverse DFT of U U (or V V resp.) may not be real. Our proof above instead uses property (11) to construct U U and V V and thus avoids this issue. Our proof further leads to a more efficient way for computing t-SVD shown in Algorithm 2. It is known that the singular values of a matrix have the decreasing order property. Let A A ¼ U U Ã S S Ã V V Ã be the t-SVD of A A 2 R n 1 Ân 2 Ân 3 . The entries on the diagonal of the first frontal slice S Sð:; :; 1Þ of S S have the same decreasing property, i.e., S Sð1; 1; 1Þ ! S Sð2; 2; 1Þ ! Á Á Á ! S Sðn 0 ; n 0 ; 1Þ ! 0; (18) where n 0 ¼ minðn 1 ; n 2 Þ. The above property holds since the inverse DFT gives and the entries on the diagonal of S Sð:; :; jÞ are the singular values of A Að:; :; jÞ. As will be seen in Section 3, the tensor nuclear norm depends only on the first frontal slice S Sð:; :; 1Þ. Thus, we call the entries on the diagonal of S Sð:; :; 1Þ as the singular values of A A. Definition 2.6 ((Tensor tubal rank) [13], [31]). For A A 2 R n 1 Ân 2 Ân 3 , the tensor tubal rank, denoted as rank t ðA AÞ, is defined as the number of nonzero singular tubes of S S, where S S is from the t-SVD of A A ¼ U U Ã S S Ã V V Ã . We can write rank t ðA AÞ ¼ #fi; S Sði; i; :Þ 6 ¼ 0 0g: By using property (19), the tensor tubal rank is determined by the first frontal slice S Sð:; :; 1Þ of S S, i.e., rank t ðA AÞ ¼ #fi; S Sði; i; 1Þ 6 ¼ 0g: Hence, the tensor tubal rank is equivalent to the number of nonzero singular values of A A. This property is the same as the matrix case. Define is the best approximation of A A with the tubal rank at most k. It is known that the real color images can be well approximated by low-rank matrices on the three channels independently. If we treat a color image as a three way tensor with each channel corresponding to a frontal slice, then it can be well approximated by a tensor of low tubal rank. A similar observation was found in [10] with the application to facial recognition. Fig. 3 gives an example to show that a color image can be well approximated by a low tubal rank tensor since most of the singular values of the corresponding tensor are relatively small. In Section 3, we will define a new tensor nuclear norm which is the convex surrogate of the tensor average rank defined as follows. This rank is closely related to the tensor tubal rank. Definition 2.7 (Tensor average rank). For A A 2 R n 1 Ân 2 Ân 3 , the tensor average rank, denoted as rank a ðA AÞ, is defined as The above definition has a factor 1 n 3 . Note that this factor is crucial in this work as it guarantees that the convex envelope of the tensor average rank within a certain set is the tensor nuclear norm defined in Section 3. The underlying reason for this factor is the t-product definition. Each element of A A is repeated n 3 times in the block circulant matrix bcircðA AÞ used in the t-product. Intuitively, this factor alleviates such an entries expansion issue. There are some connections between different tensor ranks and these properties imply that the low tubal rank or low average rank assumptions are reasonable for their applications in real visual data. First, rank a ðA AÞ rank t ðA AÞ. Indeed, where the first equality uses (10). This implies that a low tubal rank tensor always has low average rank. Second, let rank tc ðA AÞ ¼ ðrankðA A f1g Þ; rankðA A f2g Þ; rankðA A f3g ÞÞ, where A A fig is the mode-i matricization of A A, be the Tucker rank of A A. Then rank a ðA AÞ rankðA A f1g Þ. This implies that a tensor with low Tucker rank has low average rank. The low Tucker rank assumption used in some applications, e.g., image completion [17], is applicable to the low average rank assumption. Third, if the CP rank of A A is r, then its tubal rank is at most r [30]. i , where a a i Þ. So A A has the CP rank at most r, and each frontal slice of A A is the sum of r rank-1 matrices. Thus, the tubal rank of A A is at most r. In summary, we show that the low average rank assumption is weaker than the low Tucker rank and low CP rank assumptions. In this section, we propose a new tensor nuclear norm which is a convex surrogate of tensor average rank. Based on t-SVD, one may have many different ways to define the tensor nuclear norm intuitively. We give a new and rigorous way to deduce the tensor nuclear norm from the t-product, such that the concepts and their properties are consistent with the matrix cases. This is important since it guarantees that the theoretical analysis of the tensor nuclear norm based tensor RPCA model in Section 4 can be done in a similar way to RPCA. Fig. 4 summarizes the way for the new definitions and their relationships. It begins with the known operator norm [1] and t-product. First, the tensor spectral norm is induced by the tensor operator norm by treating the t-product as an operator. Then the tensor nuclear norm is defined as the dual norm of the tensor spectral norm. Finally, we show that the tensor nuclear norm is the convex envelope of the tensor average rank within the unit ball of the tensor spectral norm. Let us first recall the concept of operator norm [1]. Let ðV; k Á k V Þ and ðW; k Á k W Þ be normed linear spaces and L : V ! W be the bounded linear operator between them, respectively. The operator norm of L is defined as As a special case, if L LðV VÞ ¼ A A Ã V V, where A A 2 R n 1 Ân 2 Ân 3 and V V 2 V , then the tensor operator norm (22) gives the tensor spectral norm, denoted as kA Ak,  Then the tensor nuclear norm is defined as the dual norm of the tensor spectral norm. We also define the tensor average rank and show that its convex envelope is the tensor nuclear norm within the unit ball of the tensor spectral norm. As detailed in Section 3, the tensor spectral norm, tensor nuclear norm and tensor average rank are also defined on the matricization of the tensor. kA Ak :¼ sup ¼ kbcircðA AÞk; where ( 23) uses ( 14), and ( 24) uses the definition of matrix spectral norm. Definition 3.1 (Tensor spectral norm). The tensor spectral norm of A A 2 R n 1 Ân 2 Ân 3 is defined as kA Ak :¼ kbcircðA AÞk. By ( 7) and ( 10), we have This property is frequently used in this work. It is known that the matrix nuclear norm is the dual norm of the matrix spectral norm. Thus, we define the tensor nuclear norm, denoted as kA Ak Ã , as the dual norm of the tensor spectral norm. For any B B 2 R n 1 Ân 2 Ân 3 and B B 2 C n 1 n 3 Ân 2 n 3 , we have where ( 27) is from ( 13), ( 28) is due to the fact that B B is a block diagonal matrix in C n 1 n 3 Ân 2 n 3 while B B is an arbitrary matrix in C n 1 n 3 Ân 2 n 3 , (29) uses the fact that the matrix nuclear norm is the dual norm of the matrix spectral norm, and (30) uses ( 10) and (7). Now we show that there exists B B 2 R n 1 Ân 2 Ân 3 such that the equality (28) holds and thus kA Ak Ã ¼ 1 Combining ( 26), ( 27), ( 28), (29), and ( 30) and ( 31) and (32) leads to kA Ak Ã ¼ 1 n 3 kbcircðA AÞk Ã . On the other hand, by ( 31) and (32), we have where r ¼ rank t ðA AÞ is the tubal rank. Thus, we have the following definition of tensor nuclear norm. where r ¼ rank t ðA AÞ. From (33), it can be seen that only the information in the first frontal slice of S S is used when defining the tensor nuclear norm. Note that this is the first work which directly uses the singular values S Sð:; :; 1Þ of a tensor to define the tensor nuclear norm. Such a definition makes it consistent with the matrix nuclear norm. The above TNN definition is also different from existing works [18], [26], [31]. It is known that the matrix nuclear norm kA Ak Ã is the convex envelope of the matrix rank rankðA AÞ within the set fA AjkA Ak 1g [9]. Now we show that the tensor average rank and tensor nuclear norm have the same relationship. Theorem 3.1. On the set fA A 2 R n 1 Ân 2 Ân 3 jkA Ak 1g, the convex envelope of the tensor average rank rank a ðA AÞ is the tensor nuclear norm kA Ak Ã . We would like to emphasize that the proposed tensor spectral norm, tensor nuclear norm and tensor ranks are not arbitrarily defined. They are rigorously induced by the t-product and t-SVD. These concepts and their relationships are consistent with the matrix cases. This is important for the proofs, analysis and computation in optimization. Table 1 summarizes the parallel concepts in sparse vector, low-rank matrix and low-rank tensor. With these elements in place, the existing proofs of low-rank matrix recovery provide a template for the more general case of low-rank tensor recovery. Also, from the above discussions, we have the property It is interesting to understand the tensor nuclear norm from the perspectives of bcircðA AÞ and A A. The block circulant matrix can be regarded as a new way of matricization of A A in the original domain. The frontal slices of A A are arranged in a circulant way, which is expected to preserve more spacial relationships across frontal slices, compared with previous matricizations along a single dimension. Also, the block diagonal matrix A A can be regarded as a matricization of A A in the Fourier domain. Its blocks on the diagonal are the frontal slices of A A, which contains the information across frontal slices of A A due to the DFT on A A along the third dimension. So bcircðA AÞ and A A play a similar role to matricizations of A A in different domains. Both of them capture the spacial information within and across frontal slices of A A. This intuitively supports our tensor nuclear norm definition. Let A A ¼ U US SV V Ã be the skinny SVD of A A. It is known that any subgradient of the nuclear norm at A A is of the form [29]. Similarly, for A A 2 R n 1 Ân 2 Ân 3 with tubal rank r, we also have the skinny t-SVD, i.e., A A ¼ U U Ã S S Ã V V Ã , where U U 2 R n 1 ÂrÂn 3 , S S 2 R rÂrÂn 3 , and V V 2 R n 2 ÂrÂn 3 , in which U U Ã Ã U U ¼ I I and V V Ã Ã V V ¼ I I. The skinny t-SVD will be used throughout this paper. With skinny t-SVD, we introduce the subgradient of the tensor nuclear norm, which plays an important role in the proofs. A A 2 R n 1 Ân 2 Ân 3 with rank t ðA AÞ ¼ r and its skinny t-SVD be A With TNN defined above, we now consider the exact recovery guarantee of TRPCA in (5). The problem we study here is to recover a low tubal rank tensor L L 0 from highly corrupted measurements X X ¼ L L 0 þ S S 0 . In this section, we show that under certain assumptions, the low tubal rank part L L 0 and sparse part S S 0 can be exactly recovered by solving convex program (5). We will also give the optimization detail for solving (5). Recovering the low-rank and sparse components from their sum suffers from an identifiability issue. For example, the tensor X X , with x ijk ¼ 1 when i ¼ j ¼ k ¼ 1 and zeros everywhere else, is both low-rank and sparse. One is not able to identify the low-rank component and the sparse component in this case. To avoid such pathological situations, we need to assume that the low-rank component L L 0 is not sparse. To this end, we assume L L 0 to satisfy some incoherence conditions. We denote e i as the tensor column basis, which is a tensor of size n 1 Â 1 Â n 3 with its ði; 1; 1Þth entry equaling 1 and the rest equaling 0 [30]. We also define the tensor tube basis _ e k , which is a tensor of size 1 Â 1 Â n 3 with its ð1; 1; kÞth entry equaling 1 and the rest equaling 0. The exact recovery guarantee of RPCA [3] also requires some incoherence conditions. Due to property (12), conditions (35) and ( 36) have equivalent matrix forms in the Fourier domain, and they are intuitively similar to the matrix incoherence conditions (1.2) in [3]. But the joint incoherence condition (37) is more different from the matrix case (1.3) in [3], since it does not have an equivalent matrix form in the Fourier domain. As observed in [4], the joint incoherence condition is not necessary for low-rank matrix completion. However, for RPCA, it is unavoidable for polynomial-time algorithms. In our proofs, the joint incoherence (37) condition is necessary. Another identifiability issue arises if the sparse tensor S S 0 has low tubal rank. This can be avoided by assuming that the support of S S 0 is uniformly distributed. Now we show that the convex program ( 5) is able to perfectly recover the low-rank and sparse components. We define n ð1Þ ¼ maxðn 1 ; n 2 Þ and n ð2Þ ¼ minðn 1 ; n 2 Þ. Theorem 4.1. Suppose that L L 0 2 R nÂnÂn 3 obeys (35)-(37). Fix any n Â n Â n 3 tensor M M of signs. Suppose that the support set V V of S S 0 is uniformly distributed among all sets of cardinality m, and that sgn ½S S 0 ijk ¼ ½M M ijk for all ði; j; kÞ 2 V V. Then, there exist universal constants c 1 ; c 2 > 0 such that with probability at least 1 À c 1 ðnn 3 Þ Àc 2 (over the choice of support of S S 0 ), ðL L 0 ; S S 0 Þ is the unique minimizer to (5) mðlog ðn ð1Þ n 3 ÞÞ 2 and m r s n 1 n 2 n 3 . The above result shows that for incoherent L L 0 , the perfect recovery is guaranteed with high probability for rank t ðL L 0 Þ on the order of nn 3 =ðmðlog nn 3 Þ 2 Þ and a number of nonzero entries in S S 0 on the order of n 2 n 3 . For S S 0 , we make only one assumption on the random location distribution, but no assumption about the magnitudes or signs of the nonzero entries. Also TRPCA is parameter free. The mathematical analysis implies that the parameter ¼ 1= ffiffiffiffiffiffiffiffi nn 3 p leads to the correct recovery. Moreover, since the t-product of 3-way tensors reduces to the standard matrix-matrix product when n 3 ¼ 1, the tensor nuclear norm reduces to the matrix nuclear norm. Thus, RPCA is a special case of TRPCA and the guarantee of RPCA in Theorem 1.1 in [3] is a special case of our Theorem 4.1. Both our model and theoretical guarantee are consistent with RPCA. Compared with SNN [12], our tensor extension of RPCA is much more simple and elegant. The detailed proof of Theorem 4.1 can be found in the supplementary material, which can be found on the Computer Society Digital Library at http://doi.ieeecomputersociety. org/10.1109/TPAMI.2019.2891760. It is interesting to understand our proof from the perspective of the following equivalent formulation where (34) is used. Program ( 39) is a mixed model since the low-rank regularization is performed on the Fourier domain while the sparse regularization is performed on the original domain. Our proof of Theorem 4.1 is also conducted based on the interaction between both domains. By interpreting the tensor nuclear norm of L L as the matrix nuclear norm of L L (with a factor 1 n 3 ) in the Fourier domain, we are then able to use some existing properties of the matrix nuclear norm in the proofs. The analysis for the sparse term is kept on the original domain since the ' 1 -norm has no equivalent form in the Fourier domain. Though both two terms of the objective function of (39) are given on two matrices ( L L and bcircðE EÞ), the analysis for model (39) is very different from that of matrix RPCA. The matrices L L and bcircðE EÞ can be regarded as two matricizations of the tensor objects L L and E E, respectively. Their structures are more complicated than those in matrix RPCA, and thus make the proofs different from [3]. For example, our proofs require proving several bounds of norms on random tensors. Theses results and proofs, which have to use the properties of block circulant matrices and the Fourier transformation, are completely new. Some proofs are challenging due to the dependent structure of bcircðE EÞ for E E with an independent elements assumption. Also, TRPCA is of a different nature from the tensor completion problem [30]. The proof of the exact recovery of TRPCA is more challenging since the ' 1 -norm (and its dual norm ' 1 -norm used in (37)) has no equivalent formulation in the Fourier domain. It is worth mentioning that this work focuses on the analysis for 3-way tensors. But it is not difficult to generalize our model in (5) and results in Theorem 4.1 to the case of order-p (p ! 3) tensors, by using the t-SVD for order-p tensors in [21]. When considering the application of TRPCA, the way for constructing a 3-way tensor from data is important. The reason is that the t-product is orientation dependent, and so is the tensor nuclear norm. Thus, the value of TNN may be different if the tensor is rotated. For example, a 3-channel color image can be formatted as 3 different sizes of tensors. Therefore, when using TRPCA which is based on TNN, one has to format the data into tensors in a proper way by leveraging some priori knowledge, e.g., the low tubal rank property of the constructed tensor. Problem ( 5) can be solved by the standard Alternating Direction Method of Multiplier (ADMM) [19]. A key step is to compute the proximal operator of TNN We show that it also has a closed-form solution as the proximal operator of the matrix nuclear norm. Let Y Y ¼ U U Ã S S Ã V V Ã be the tensor SVD of Y Y 2 R n 1 Ân 2 Ân 3 . For each t > 0, we define the tensor Singular Value Thresholding (t-SVT) operator as follows where Note that S S is a real tensor. Above t þ denotes the positive part of t, i.e., t þ ¼ maxðt; 0Þ. That is, this operator simply applies a soft-thresholding rule to the singular values S S (not S S) of the frontal slices of Y Y, effectively shrinking these towards zero. The t-SVT operator is the proximity operator associated with TNN. Theorem 4.2. For any t > 0 and Y Y 2 R n 1 Ân 2 Ân 3 , the tensor singular value thresholding operator (41) obeys Proof. The required solution to (43) is a real tensor and thus we first show that D t ðY YÞ in (41) is real. Let Y Y ¼ U U Ã S S Ã V V Ã be the tensor SVD of Y Y. We know that the frontal slices of S S satisfy the property (11) and so do the frontal slices of ð S S À tÞ þ . By Lemma 2.1, S S t in (42) is real. Thus, D t ðY YÞ in (41) is real. Second, by using properties (34) and ( 12), problem (43) is equivalent to end for for i ¼ d Theorem 4.2 gives the closed-form of the t-SVT operator D t ðY YÞ, which is a natural extension of the matrix SVT [2]. Note that D t ðY YÞ is real when Y Y is real. By using property (11), Algorithm 3 gives an efficient way for computing D t ðY YÞ. With t-SVT, we now give the details of ADMM to solve (5). The augmented Lagrangian function of ( 5) is end while In this section, we conduct numerical experiments to verify our main results in Theorem 4.1. We first investigate the ability of the convex TRPCA model ( 5) to recover tensors with varying tubal rank and different levels of sparse noises. We then apply it for image recovery and background modeling. As suggested by Theorem 4.1, we set ¼ 1= ffiffiffiffiffiffiffiffiffiffiffiffi ffi n ð1Þ n 3 p in all the experiments. 1 But note that it is possible to further improve the performance by tuning more carefully. The suggested value in theory provides a good guide in practice. All the simulations are conducted on a PC with an Intel Xeon E3-1270 3.60 GHz CPU and 64 GB memory. We first verify the correct recovery guarantee of Theorem 4.1 on randomly generated problems. We simply consider the tensors of size n Â n Â n, with varying dimension n ¼100 and 200. We generate a tensor with tubal rank r as a product L L 0 ¼ P P Ã Q Q Ã , where P P and Q Q are n Â r Â n tensors with entries independently sampled from N ð0; 1=nÞ distribution. The support set V V (with size m) of E E 0 is chosen uniformly at random. For all ði; j; kÞ 2 V V, let ½E E 0 ijk ¼ M M ijk , where M M is a tensor with independent Bernoulli AE1 entries. Table 2 reports the recovery results based on varying choices of the tubal rank r of L L 0 and the sparsity m of E E 0 . It can be seen that our convex program (5) gives the correct tubal rank estimation of L L 0 in all cases and also the relative errors k L L À L L 0 k F =kL L 0 k F are very small, less than 10 À5 . The sparsity estimation of E E 0 is not as exact as the rank estimation, but note that the relative errors k Ê E À E E 0 k F =kE E 0 k F are all very small, less than 10 À8 (actually much smaller than the relative errors of the recovered low-rank component). These results well verify the correct recovery phenomenon as claimed in Theorem 4.1. The results in Theorem 4.1 show the perfect recovery for incoherent tensor with rank t ðL L 0 Þ on the order of nn 3 =ðmðlog nn 3 Þ 2 Þ and the sparsity of E E 0 on the order of n 2 n 3 . Now we examine the recovery phenomenon with varying tubal rank of L L 0 from varying sparsity of E E 0 . We consider the tensor L L 0 of size R nÂnÂn 3 , where n ¼ 100 and n 3 ¼ 50. We generate L L 0 ¼ P P Ã Q Q Ã , where P P and Q Q are n Â r Â n 3 tensors with entries independently sampled from a N ð0; 1=nÞ distribution. For the sparse component E E 0 , we consider two cases. In the first case, we assume a Bernoulli model for the support of the sparse term E E 0 , with random signs: each entry of E E 0 takes on value 0 with probability 1 À r, and values AE1 each with probability r=2. The second case chooses the support V V in accordance with the Bernoulli model, but this time sets E E 0 ¼ P P V V sgnðL L 0 Þ. We set r n ¼ ½0:01 : 0:01 : 0:5 and . Fig. 5 plots the fraction of correct recovery for each pair ð r n ; r s Þ (black = 0% and white = 100%). It can be seen that there is a large region in which the recovery is correct in both cases. Intuitively, the experiment shows that the recovery is correct when the tubal rank of L L 0 is relatively low and the errors E E 0 is relatively sparse. Fig. 5b further shows that the signs of E E 0 are not important: recovery can be guaranteed as long as its support is chosen uniformly at random. These observations are consistent with Theorem 4.1. Similar observations can be found in the matrix RPCA case (see Fig. 1 in [3]). We apply TRPCA to image recovery from the corrupted images with random noises.The motivation is that the color images can be approximated by low rank matrices or tensors [17]. We will show that the recovery performance of TRPCA is still satisfactory with the suggested parameter in theory on real data. We use 100 color images from the Berkeley Segmentation Dataset [22] for the test. The sizes of images are 321 Â 481 or 481 Â 321. For each image, we randomly set 10 percent of pixels to random values in [0, 255], and the positions of the corrupted pixels are unknown. All the 3 channels of the images are corrupted at the same positions (the corruptions are on the whole tubes). This problem is more challenging than the corruptions on 3 channels at different positions. See Fig. 7b for some sample images with noises. We compare our TRPCA model with RPCA [3] and SNN [12] which also own the theoretical recovery guarantee. For RPCA, we apply it on each channel separably and combine the results to obtain the recovered image. The parameter is set to ¼ 1= ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi maxðn 1 ; n 2 Þ p as suggested in theory. For SNN in (4), we find that it does not perform well when i 's are set to the values suggested in theory [12]. We empirically set ¼ ½15; 15; 1:5 in (4) to make SNN perform well in most cases. For our TRPCA, we format a n 1 Â n 2 sized image as a tensor of size n 1 Â n 2 Â 3. We find that such a way of tensor construction usually performs better than some other ways. This may be due to the noises which present on the tubes. We set ¼ 1= ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi 3 maxðn 1 ; n 2 Þ p in TRPCA. We use the Peak Signal-to-Noise Ratio (PSNR), defined as to evaluate the recovery performance. Fig. 6 gives the comparison of the PSNR values and running time on all 100 images. Some examples with the recovered images are shown in Fig. 7. From these results, we have the following observations. First, both SNN and TRPCA perform much better than the matrix based RPCA. The reason is that RPCA performs on each channel independently, and thus is not able to use the information across channels. The tensor methods instead take advantage of the multi-dimensional structure of data. Second, TRPCA outperforms SNN in most cases. This not only demonstrates the superiority of our TRPCA, but also validates our recovery guarantee in Theorem 4.1 on image data. Note that SNN needs some additional effort to tune the weighted parameters i 's empirically. Different from SNN which is a loose convex surrogate of the sum of Tucker rank, our TNN is a tight convex relaxation of the tensor average rank, and the recovery performance of the obtained optimal solutions has the tight recovery guarantee as RPCA. Third, we use the standard ADMM to solve RPCA, SNN and TRPCA. Fig. 6 (bottom) shows that TRPCA is as efficient as RPCA, while SNN requires the highest cost in this experiment. In this section, we consider the background modeling problem which aims to separate the foreground objects from the background. The frames of the background are highly correlated and thus can be modeled as a low rank tensor. The moving foreground objects occupy only a fraction of image pixels and thus can be treated as sparse errors. We solve this problem by using RPCA, SNN and TRPCA. We consider four color videos, Hall (144Â176, 300), WaterSurface (128Â160, 300), ShoppingMall (256Â320, 100) and ShopCorridor (144Â192, 200), where the numbers in the parentheses denote the frame size and the frame number. For each sequence with color frame size h Â w and frame number k, we reshape it to a ð3hwÞ Â k matrix and use it in RPCA. To use SNN and TRPCA, we reshape the video to a ðhwÞ Â 3 Â k tensor. 2 The parameter of SNN in (4) is set to ¼ ½10; 0:1; 1 Â 20 in this experiment. Fig. 8 shows the performance and running time comparison of RPCA, SNN and TRPCA on the four sequences. It can be seen that the low rank components identify the main illuminations as background, while the sparse parts correspond to the motion in the scene. Generally, our TRPCA performs the best. RPCA does not perform well on the Hall and WaterSurface sequences using the default parameter. Also, TRPCA is as efficient as RPCA and SNN requires much higher computational cost. The efficiency of TRPCA is benefited from our faster way for computing tensor SVT in Algorithm 3 which is the key step for solving TRPCA. Based on the recently developed tensor-tensor product, which is a natural extension of the matrix-matrix product, we rigorously defined the tensor spectral norm, tensor nuclear norm and tensor average rank, such that their properties and relationships are consistent with the matrix cases. We then 2. We observe that this way of tensor construction performs well for TRPCA, despite one has some other ways. studied the Tensor Robust Principal Component problem which aims to recover a low tubal rank tensor and a sparse tensor from their sum. We proved that under certain suitable assumptions, we can recover both the low-rank and the sparse components exactly by simply solving a convex program whose objective is a weighted combination of the tensor nuclear norm and the ' 1 -norm. Benefitting from the \"good\" property of tensor nuclear norm, both our model and theoretical guarantee are natural extensions of RPCA. We also developed a more efficient method to compute the tensor singular value thresholding problem which is the key for solving TRPCA. Numerical experiments verify our theory and the results on images and videos demonstrate the effectiveness of our model. There have some interesting future works. The work [7] generalizes the t-product using any invertible linear transform. With a proper choice of the invertible linear transform, it is possible to deduce a new tensor nuclear norm and solve the TRPCA problem. Beyond the convex models, the extensions to nonconvex cases are also important [20]. Finally, it is always interesting in using the developed tensor tools for real applications, e.g., image/video processing, web data analysis, and bioinformatics. kV Vk F 1 kL LðV VÞk F : a 0162-8828 ß 2019 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.See ht_ tps://www.ieee.org/publications/rights/index.html for more information. Authorized licensed use limited to: Queen Mary University of London. Downloaded on March 23,2025 at 00:30:00 UTC from IEEE Xplore. Restrictions apply. Authorized licensed use limited to: Queen Mary of London. Downloaded on March 23,2025 00:30:00 UTC from IEEE Xplore. Restrictions apply.",
  "filePath": "C:\\Users\\Alex Isaev\\Documents\\truth source\\citation-verifier\\src\\document-database\\documents\\tensor_robust_principal_component_analysis_with_a_new_tensor_nuclear_norm.json",
  "sourcePdf": "C:\\Users\\Alex Isaev\\Documents\\truth source\\citation-verifier\\src\\document-database\\pdf-documents\\25.pdf",
  "doi": "10.1109/TPAMI.2019.2891760",
  "year": "",
  "journal": ""
}